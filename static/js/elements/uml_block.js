// Generated by CoffeeScript 1.9.1
(function() {
  var min_container_width, min_field_box_height, min_label_box_height, min_method_box_height, percents_per_label, uml_block_class,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  uml_block_class = 'uml_block';

  min_container_width = 200;

  percents_per_label = 14;

  min_label_box_height = 25;

  min_method_box_height = 25;

  min_field_box_height = 25;

  this.UMLBlock = (function(superClass) {
    extend(UMLBlock, superClass);

    function UMLBlock(board, params1, hash) {
      this.board = board;
      this.params = params1;
      this.hash = hash;
      UMLBlock.__super__.constructor.call(this, this.board, 'uml-block', this.params, this.hash);
      if (!this.hash) {
        this.hash = Math.random().toString(36).substr(2, 15);
      }
      this.svg = this.board.getBoard();
      this.focused = false;
      this.container = this.svg.rect(1, 1, 100, 100);
      this.container.addClass(uml_block_class + '__container');
      this.label_box = this.svg.rect(1, 1, 1, 1);
      this.label_box.addClass(uml_block_class + '__label_box');
      this.uml_block = this.svg.group(this.container, this.label_box);
      this.uml_block.addClass('uml_block');
      this.redraw();
      this.drag();
      this.setFocusable();
    }

    UMLBlock.prototype.recalculate_dimensions = function() {
      var default_field_height, default_label_height;
      if (this.params.width < min_container_width) {
        this.params.width = min_container_width;
      }
      default_label_height = this.params.height * percents_per_label / 100;
      this.label_height = default_label_height < min_label_box_height ? min_label_box_height : default_label_height;
      this.fields_count = Object.keys(this.params.fields).length;
      this.methods_count = Object.keys(this.params.methods).length;
      default_field_height = (this.params.height - this.label_height) / (this.fields_count + this.methods_count);
      this.method_height = default_field_height < min_method_box_height ? min_method_box_height : default_field_height;
      return this.field_height = default_field_height < min_field_box_height ? min_field_box_height : default_field_height;
    };

    UMLBlock.prototype.redraw = function() {
      var container_height;
      UMLBlock.__super__.redraw.call(this);
      this.recalculate_dimensions();
      container_height = this.label_height + this.method_height * this.methods_count + this.field_height * this.fields_count;
      this.container.attr({
        width: this.params.width,
        height: container_height,
        x: this.params.x,
        y: this.params.y
      });
      return this.label_box.attr({
        x: this.params.x,
        y: this.params.y,
        width: this.params.width,
        height: this.label_height
      });
    };

    UMLBlock.prototype.setFocusable = function() {
      programEvents.on('util-changed', (function(_this) {
        return function() {
          if (_this.focused) {
            _this.unfocus();
            return _this.emit('unfocus');
          }
        };
      })(this));
      this.svg.click((function(_this) {
        return function(e) {
          if (!_this.focused) {
            return;
          }
          e.stopPropagation();
          e.cancelBubble = true;
          if (Board.utility_name === 'select') {
            _this.unfocus();
            return _this.emit('unfocus');
          }
        };
      })(this));
      return this.uml_block.click((function(_this) {
        return function(e) {
          e.stopPropagation();
          e.cancelBubble = true;
          if (Board.utility_name === 'select' && !_this.focused) {
            _this.focus();
            return _this.emit('focus');
          }
        };
      })(this));
    };

    UMLBlock.prototype.focus = function() {
      this.focused = true;
      return console.log('focus');
    };

    UMLBlock.prototype.unfocus = function() {
      this.focused = false;
      return console.log('unfocus');
    };

    UMLBlock.prototype.drag = function() {
      var beforeDragPoint, dragHandler, dragStart;
      beforeDragPoint = {
        x: 0,
        y: 0
      };
      dragStart = (function(_this) {
        return function() {
          beforeDragPoint.x = _this.params.x;
          return beforeDragPoint.y = _this.params.y;
        };
      })(this);
      dragHandler = (function(_this) {
        return function(dx, dy) {
          if (Board.utility_name !== 'hand') {
            return;
          }
          _this.params.x = beforeDragPoint.x + dx;
          _this.params.y = beforeDragPoint.y + dy;
          _this.redraw();
          return _this.save();
        };
      })(this);
      return this.uml_block.drag(dragHandler, dragStart);
    };

    UMLBlock.prototype.update = function(params) {
      UMLBlock.__super__.update.call(this, params);
      return this.redraw();
    };

    return UMLBlock;

  })(DefaultElement);

}).call(this);

//# sourceMappingURL=uml_block.js.map
